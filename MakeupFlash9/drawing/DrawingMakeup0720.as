package {		import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.DisplayObject;	import flash.display.BitmapData;	import flash.geom.ColorTransform;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.display.SimpleButton;	import flash.ui.Mouse;	import flash.display.Bitmap;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;		public class DrawingMakeup0720 extends MovieClip	{		private var pencilDraw:Shape = new Shape();				private var actived:String;		private var board:MovieClip;		private var stroke1:MovieClip;		private var stroke1gray:SimpleButton;		private var stroke2:MovieClip;		private var stroke2gray:SimpleButton;		private var colors:MovieClip;		private var showColor:MovieClip;		private var pickupBtn_mc:MovieClip;		    private var activedColor:uint = 0x463b3b;	    private var colorsBmd:BitmapData;		private var pixelValue:uint;		private var ct:ColorTransform = new ColorTransform();				private var undoTool:SimpleButton;		private var deletTool:SimpleButton;				private var showBrush_mc:MovieClip;				private var isDrawing:Boolean;				private var oldX:int;		private var oldY:int;				private var brush_bm:Bitmap;			// our "permanent" (at least until cleared) bitmap		private var brush_bmArray:Array;		// some number of bitmaps to support undo functionality				private var brush1_mc:MovieClip;				//private const MAX_MOVE = 200;				private const MAX_UNDO = 10;		private const BOARD_WIDTH = 500;		private const BOARD_HEIGHT = 200;			private var curr_undo:int;				private var WHOLE_RECT:Rectangle;		private var TOPLEFT:Point;						public function DrawingMakeup0720():void		{			curr_undo = 0;			WHOLE_RECT = new Rectangle(0,0,BOARD_WIDTH,BOARD_HEIGHT);			TOPLEFT = new Point(0,0);						createBoard();			createBrushes();			createInterface();			this.addEventListener(MouseEvent.MOUSE_DOWN,handleMouseDown);			this.addEventListener(MouseEvent.MOUSE_UP,handleMouseUp);			this.addEventListener(Event.ADDED_TO_STAGE,addMouseTracker);					}				private function createBoard()		{						board = new Board();			addChild(board);			board.alpha=1;			board.x=0;			board.y=0;												brush_bmArray = new Array();			// create the base bitmap (brush_bm)			brush_bm = new Bitmap();			brush_bm.bitmapData = new BitmapData(BOARD_WIDTH,BOARD_HEIGHT,true,0x00FFFFFF);			addChild(brush_bm);						// create an array to hold N bitmaps to support N levels of undo			// (controlled by MAX_UNDO)			for (var i:int = 1; i<=MAX_UNDO; i++)			{				brush_bmArray[i] = new Bitmap();				brush_bmArray[i].bitmapData = new BitmapData(BOARD_WIDTH,BOARD_HEIGHT,true,0x00FFFFFF);				addChild(brush_bmArray[i]);								// brush_bmArray[i].y = (i) * 200;								trace('created new bitmap!');							}			}				private function createBrushes()		{			brush1_mc = new brush1();					}				private function createInterface()		{			pickupBtn_mc = new pickupBtn();			addChild(pickupBtn_mc);			pickupBtn_mc.visible = false;			pickupBtn_mc.x=900;			pickupBtn_mc.y=80;									deletTool = new deletTool_mc();			addChild(deletTool);			deletTool.x=1000;			deletTool.y=500;						undoTool = new clearIcon_mc();			addChild(undoTool);			undoTool.x=900;			undoTool.y=500;						//------------color--要放在前面  因為沒有先 addChlid 會讀不到			colors = new to_colors_mc();			addChild(colors);			colors.x=900;			colors.y=300;						colorsBmd = new BitmapData(colors.width,colors.height);			colorsBmd.draw(colors);					//------add stroke1----			stroke1gray = new stroke1gray_mc();			addChild(stroke1gray);			stroke1gray.x=900;			stroke1gray.y=400;						stroke1 = new stroke1_mc();			addChild(stroke1);			stroke1.x=900;			stroke1.y=400;						//---------stroke2			stroke2gray = new stroke2gray_mc();			//addChild(stroke2gray);			stroke2gray.x=900;			stroke2gray.y=200;						stroke2 = new stroke2_mc();			//addChild(stroke2);			stroke2.x=900;			stroke2.y=200;			stroke1.visible = false;			stroke2.visible = false;			showBrush_mc = new showBrush();			addChild(showBrush_mc);			showBrush_mc.visible = false;			showBrush_mc.x=400;			showBrush_mc.y=500;								deletTool.addEventListener(MouseEvent.MOUSE_DOWN, deletToolFunction);			undoTool.addEventListener(MouseEvent.MOUSE_UP, undoBoard);			colors.addEventListener(MouseEvent.MOUSE_DOWN, chooseColor);			stroke1gray.addEventListener(MouseEvent.MOUSE_UP, strokeTool1);			stroke2gray.addEventListener(MouseEvent.MOUSE_UP, strokeTool2);								}				private function resetData()		{									brush_bm.bitmapData.dispose();			brush_bm.bitmapData = new BitmapData(BOARD_WIDTH,BOARD_HEIGHT,true,0x00FFFFFF);						for (var i:int =1; i<= MAX_UNDO; i++)			{				brush_bmArray[i].bitmapData.dispose();				brush_bmArray[i].bitmapData = new BitmapData(BOARD_WIDTH,BOARD_HEIGHT,true,0x00FFFFFF);							}						curr_undo = 0;									//this.actived = null; // which tool we're using			isDrawing = false; 	// whether or not we're drawing					}				private function addMouseTracker(e:Event)		{			stage.addEventListener(MouseEvent.MOUSE_MOVE,handleMouseMove);					}				private function handleMouseDown(evt:MouseEvent)		{			// this.startstrokeTool(actived,evt);			trace('down! ' + actived);						if (evt.target is Board)			{				trace('incrementing undo');				curr_undo += 1;				if (curr_undo >MAX_UNDO)				{					promote_strokes(); //move to next layer					curr_undo = MAX_UNDO;				}								switch (actived)				{					case "Stroke1" :						this.startstrokeTool(3,evt);						break;					case "Stroke2" :						this.startstrokeTool(2,evt);						break;				}							}					}				private function handleMouseMove(evt:MouseEvent)		{			//trace(mouseX,mouseY);			// check to see if we are both 1) currently drawing, and 2) out of bounds			// if so, stop drawing			if (this.isDrawing)			{				// are we out of bounds? 				if (mouseX < 0 || mouseX > BOARD_WIDTH || mouseY < 0 || mouseY > BOARD_HEIGHT)				{					trace('out of bounds!');					quitactivedTool();					//stopDrawingTool(evt);				}				else				{					switch (actived) 					{						case "Stroke1":							stampLineTo(mouseX,mouseY);							break;						case "Stroke2":							pencilDraw.graphics.lineTo(mouseX, mouseY);							break;					}					showBrush_mc.x = mouseX;					showBrush_mc.y = mouseY;				}							}					// if we *are drawing, call the appropriate function based on the current tool		}				private function handleMouseUp(evt:MouseEvent)		{			trace(isDrawing + ' ' + curr_undo);			if (isDrawing)			{				quitactivedTool();			}		}				//------- Quit actived function 		private function quitactivedTool():void		{			trace('stopping drawing');			this.isDrawing = false;			showBrush_mc.visible = false;		}						private function stamp(sx:int, sy:int)		{			var m = new Matrix();			m.tx = sx;			m.ty = sy;						brush_bmArray[curr_undo].bitmapData.draw(brush1_mc,m,ct); 			// 第一個是筆刷的樣式(用movieclip的筆刷) 第二個是正列的位置 第三個是顏色		}				private function stampLineTo(sx:int, sy:int)		{			var deltaX = sx - oldX;			var deltaY = sy - oldY;						var distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);						var numstamp = Math.ceil(distance / 5);						var newx:int;			var newy:int;			var u:Number;						for (var i:int=0; i<=numstamp; i++)			{			 	u = i/numstamp;				newx = (oldX * (1-u)) + (sx * u);				newy = (oldY * (1-u)) + (sy * u);				stamp(newx,newy);			}						oldX = sx;			oldY = sy;				}				//sroke1 		private function strokeTool1(e:MouseEvent):void		{			e.stopPropagation();						trace('strokeTool1!');		    actived = "Stroke1";			highlightTool(stroke1);			hideTools(stroke2);					}		//sroke2		private function strokeTool2(e:MouseEvent):void		{			e.stopPropagation();						trace('strokeTool2!');			actived = "Stroke2";			highlightTool(stroke2);			hideTools(stroke1);					}				private function promote_strokes()		{			brush_bm.bitmapData.draw(brush_bmArray[1].bitmapData);			brush_bmArray[1].bitmapData.fillRect(WHOLE_RECT,0x00FFFFFF);					// go through our array of bitmaps and copy things			for (var i:int=2; i<=MAX_UNDO; i++)			{				// if we're on the first layer				brush_bmArray[i-1].bitmapData.draw(brush_bmArray[i].bitmapData);				brush_bmArray[i].bitmapData.fillRect(WHOLE_RECT,0x00FFFFFF);												}							}						private function startstrokeTool(style:int, evt:MouseEvent):void		{						trace('starting to draw');			pencilDraw = new Shape();			board.addChild(pencilDraw);			isDrawing = true;			pencilDraw.graphics.moveTo(mouseX, mouseY);						switch (style)			{				case 1:					pencilDraw.graphics.lineStyle(2, activedColor);							break;				case 2:					pencilDraw.graphics.lineStyle(15, activedColor);							break;				case 3:					trace('starting brush');					stamp(mouseX,mouseY);					oldX = mouseX;					oldY = mouseY;					break;			}						showBrush_mc.x = mouseX;			showBrush_mc.y = mouseY;			showBrush_mc.visible = true;		}				private function drawStroke(e:MouseEvent):void		{			pencilDraw.graphics.lineTo(mouseX, mouseY);						showBrush_mc.visible = true;			showBrush_mc.x = mouseX;			showBrush_mc.y = mouseY;					}				//------------------- Highlight Change-----------------------		private function highlightTool(tool1:DisplayObject):void		{			tool1.visible=true;					}		private function hideTools(tool2:DisplayObject):void		{			tool2.visible=false;					}		//-----color		private function chooseColor(e:MouseEvent):void		{			e.stopPropagation();// like break and to do next step (not call in the same time)			pixelValue = colorsBmd.getPixel(colors.mouseX,colors.mouseY);			activedColor = pixelValue;			ct.color = activedColor;			//showColor.transform.colorTransform = ct;			stroke2.transform.colorTransform = ct;			stroke1.strokeColorChange1.transform.colorTransform = ct; //strokeColorChange1 in stroke's movieclip		}		//----undo		private function undoBoard(e:MouseEvent):void		{			e.stopPropagation();			trace('curr_undo = ' + curr_undo);						if (curr_undo > 0)			{				brush_bmArray[curr_undo].bitmapData.fillRect(WHOLE_RECT,0x00FFFFFF);			}			curr_undo = curr_undo-1 ;			if (curr_undo < 0)			{				curr_undo = 0;			}						pencilDraw.graphics.clear();					}						//-----deletToolFunction		private function deletToolFunction(e:MouseEvent):void		{			trace('delet!')						resetData();								}			}}